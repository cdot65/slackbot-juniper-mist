{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"docs/overview/","text":"\ud83c\udf89 Welcome Example Slack bot for interfacing with your Juniper Mist environment The repository hopes to act as a guide for building bots with Slack Bolt SDK. In our example, we will be building a Python-based Slack bot that will serve as an interface to Juniper Mist. This project is structured to be more of an educational guide rather than a production-ready piece of software. \u2753 How to use this guide The navigation menu on the left hand of this site will be the best method of navigating between the documents. Slack bot This is the meat and potatoes of our documentation, even for those just looking for examples of Mist. We will cover how the bot is built, how it interacts with the user's input, and how it handles interactions with the Mist REST API. The all-important code deep dive will be taking place here, and we will discuss the various tools that are provided in the project files to make our lives easier. Mist This can be considered optional if you're only here for the Python, but it's really cool too.","title":"Overview"},{"location":"docs/overview/#welcome","text":"Example Slack bot for interfacing with your Juniper Mist environment The repository hopes to act as a guide for building bots with Slack Bolt SDK. In our example, we will be building a Python-based Slack bot that will serve as an interface to Juniper Mist. This project is structured to be more of an educational guide rather than a production-ready piece of software.","title":"\ud83c\udf89 Welcome"},{"location":"docs/overview/#how-to-use-this-guide","text":"The navigation menu on the left hand of this site will be the best method of navigating between the documents.","title":"\u2753 How to use this guide"},{"location":"docs/overview/#slack-bot","text":"This is the meat and potatoes of our documentation, even for those just looking for examples of Mist. We will cover how the bot is built, how it interacts with the user's input, and how it handles interactions with the Mist REST API. The all-important code deep dive will be taking place here, and we will discuss the various tools that are provided in the project files to make our lives easier.","title":"Slack bot"},{"location":"docs/overview/#mist","text":"This can be considered optional if you're only here for the Python, but it's really cool too.","title":"Mist"},{"location":"docs/mist/overview/","text":"\ud83d\udccc Overview Our primary goal today is to use PyEZ to provision eight Juniper vMX routers into various elements of an MPLS network. While PyEZ has the capability of pushing individual lines, or groups of lines, of configurations to a device, here we will be building and pushing an entire configuration. We will also be following the guiding principles of Infrastructure-as-Code , where we will store our the elements of our configuration as YAML, to be ran through a Jinja2 template to output our configurations. \ud83d\udc0d Files All of our project's scripts, variables, and template files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Python Scripts You likely don't need me to explain that the files that end with .py are the various Python scripts. Here is a quick glimpse into the four provided. Script Action generate.py Build the configurations locally with Jinaj2. configure.py Build and push our configurations with PyEZ. download.py Download our configurations with PyEZ. rollback.py Rollback to our bootstrap configurations with PyEZ. validate.py Validate our MPLS L3VPN circuit with JSNAPy. Inventory file The inventory.yaml file stores information about our devices, basic information like hostname and IP address. configurations/ directory If you choose to generate the configurations locally but not push them to the devices, then you will find the generated configurations within the configurations directory. I had also included the working final configurations in this directory if you just want to see the resulting configurations. templates/ directory Since we are storing our configuration as code, we will need some kind of templating engine to run our variables through to produce the configurations. For this we have Jinja2 to handle the templating, and its template files are stored in the templates directory. vars/ directory Finally, the device's configuration will be stored as YAML files found within the vars/ directory. Each device will have its own file to represent its configuration. We will run these files through the Jinaj2 templates to produce our configurations. \ud83d\udee0\ufe0f Tools In hopes to making this project as easy as possible to execute, I have provided many tools to help with execution of the tasks within this project. Poetry A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it. Invoke You will find a packaged called Invoke installed within the virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy. Dockerfile A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment. A couple of additional Invoke tasks are listed below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. invoke shell Get access to the BASH shell within our container. \ud83d\ude80 Workflow The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Run locally or within a container using the Invoke package poetry install poetry shell invoke configure","title":"Overview"},{"location":"docs/mist/overview/#overview","text":"Our primary goal today is to use PyEZ to provision eight Juniper vMX routers into various elements of an MPLS network. While PyEZ has the capability of pushing individual lines, or groups of lines, of configurations to a device, here we will be building and pushing an entire configuration. We will also be following the guiding principles of Infrastructure-as-Code , where we will store our the elements of our configuration as YAML, to be ran through a Jinja2 template to output our configurations.","title":"\ud83d\udccc Overview"},{"location":"docs/mist/overview/#files","text":"All of our project's scripts, variables, and template files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py","title":"\ud83d\udc0d Files"},{"location":"docs/mist/overview/#python-scripts","text":"You likely don't need me to explain that the files that end with .py are the various Python scripts. Here is a quick glimpse into the four provided. Script Action generate.py Build the configurations locally with Jinaj2. configure.py Build and push our configurations with PyEZ. download.py Download our configurations with PyEZ. rollback.py Rollback to our bootstrap configurations with PyEZ. validate.py Validate our MPLS L3VPN circuit with JSNAPy.","title":"Python Scripts"},{"location":"docs/mist/overview/#inventory-file","text":"The inventory.yaml file stores information about our devices, basic information like hostname and IP address.","title":"Inventory file"},{"location":"docs/mist/overview/#configurations-directory","text":"If you choose to generate the configurations locally but not push them to the devices, then you will find the generated configurations within the configurations directory. I had also included the working final configurations in this directory if you just want to see the resulting configurations.","title":"configurations/ directory"},{"location":"docs/mist/overview/#templates-directory","text":"Since we are storing our configuration as code, we will need some kind of templating engine to run our variables through to produce the configurations. For this we have Jinja2 to handle the templating, and its template files are stored in the templates directory.","title":"templates/ directory"},{"location":"docs/mist/overview/#vars-directory","text":"Finally, the device's configuration will be stored as YAML files found within the vars/ directory. Each device will have its own file to represent its configuration. We will run these files through the Jinaj2 templates to produce our configurations.","title":"vars/ directory"},{"location":"docs/mist/overview/#tools","text":"In hopes to making this project as easy as possible to execute, I have provided many tools to help with execution of the tasks within this project.","title":"\ud83d\udee0\ufe0f Tools"},{"location":"docs/mist/overview/#poetry","text":"A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it.","title":"Poetry"},{"location":"docs/mist/overview/#invoke","text":"You will find a packaged called Invoke installed within the virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy.","title":"Invoke"},{"location":"docs/mist/overview/#dockerfile","text":"A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment. A couple of additional Invoke tasks are listed below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. invoke shell Get access to the BASH shell within our container.","title":"Dockerfile"},{"location":"docs/mist/overview/#workflow","text":"The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Run locally or within a container using the Invoke package poetry install poetry shell invoke configure","title":"\ud83d\ude80 Workflow"},{"location":"docs/slackbot/overview/","text":"\ud83d\udccc Overview Our primary goal today is to use PyEZ to provision eight Juniper vMX routers into various elements of an MPLS network. While PyEZ has the capability of pushing individual lines, or groups of lines, of configurations to a device, here we will be building and pushing an entire configuration. We will also be following the guiding principles of Infrastructure-as-Code , where we will store our the elements of our configuration as YAML, to be ran through a Jinja2 template to output our configurations. \ud83d\udc0d Files All of our project's scripts, variables, and template files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Python Scripts You likely don't need me to explain that the files that end with .py are the various Python scripts. Here is a quick glimpse into the four provided. Script Action generate.py Build the configurations locally with Jinaj2. configure.py Build and push our configurations with PyEZ. download.py Download our configurations with PyEZ. rollback.py Rollback to our bootstrap configurations with PyEZ. validate.py Validate our MPLS L3VPN circuit with JSNAPy. Inventory file The inventory.yaml file stores information about our devices, basic information like hostname and IP address. configurations/ directory If you choose to generate the configurations locally but not push them to the devices, then you will find the generated configurations within the configurations directory. I had also included the working final configurations in this directory if you just want to see the resulting configurations. templates/ directory Since we are storing our configuration as code, we will need some kind of templating engine to run our variables through to produce the configurations. For this we have Jinja2 to handle the templating, and its template files are stored in the templates directory. vars/ directory Finally, the device's configuration will be stored as YAML files found within the vars/ directory. Each device will have its own file to represent its configuration. We will run these files through the Jinaj2 templates to produce our configurations. \ud83d\udee0\ufe0f Tools In hopes to making this project as easy as possible to execute, I have provided many tools to help with execution of the tasks within this project. Poetry A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it. Invoke You will find a packaged called Invoke installed within the virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy. Dockerfile A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment. A couple of additional Invoke tasks are listed below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. invoke shell Get access to the BASH shell within our container. \ud83d\ude80 Workflow The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Run locally or within a container using the Invoke package poetry install poetry shell invoke configure","title":"Overview"},{"location":"docs/slackbot/overview/#overview","text":"Our primary goal today is to use PyEZ to provision eight Juniper vMX routers into various elements of an MPLS network. While PyEZ has the capability of pushing individual lines, or groups of lines, of configurations to a device, here we will be building and pushing an entire configuration. We will also be following the guiding principles of Infrastructure-as-Code , where we will store our the elements of our configuration as YAML, to be ran through a Jinja2 template to output our configurations.","title":"\ud83d\udccc Overview"},{"location":"docs/slackbot/overview/#files","text":"All of our project's scripts, variables, and template files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py","title":"\ud83d\udc0d Files"},{"location":"docs/slackbot/overview/#python-scripts","text":"You likely don't need me to explain that the files that end with .py are the various Python scripts. Here is a quick glimpse into the four provided. Script Action generate.py Build the configurations locally with Jinaj2. configure.py Build and push our configurations with PyEZ. download.py Download our configurations with PyEZ. rollback.py Rollback to our bootstrap configurations with PyEZ. validate.py Validate our MPLS L3VPN circuit with JSNAPy.","title":"Python Scripts"},{"location":"docs/slackbot/overview/#inventory-file","text":"The inventory.yaml file stores information about our devices, basic information like hostname and IP address.","title":"Inventory file"},{"location":"docs/slackbot/overview/#configurations-directory","text":"If you choose to generate the configurations locally but not push them to the devices, then you will find the generated configurations within the configurations directory. I had also included the working final configurations in this directory if you just want to see the resulting configurations.","title":"configurations/ directory"},{"location":"docs/slackbot/overview/#templates-directory","text":"Since we are storing our configuration as code, we will need some kind of templating engine to run our variables through to produce the configurations. For this we have Jinja2 to handle the templating, and its template files are stored in the templates directory.","title":"templates/ directory"},{"location":"docs/slackbot/overview/#vars-directory","text":"Finally, the device's configuration will be stored as YAML files found within the vars/ directory. Each device will have its own file to represent its configuration. We will run these files through the Jinaj2 templates to produce our configurations.","title":"vars/ directory"},{"location":"docs/slackbot/overview/#tools","text":"In hopes to making this project as easy as possible to execute, I have provided many tools to help with execution of the tasks within this project.","title":"\ud83d\udee0\ufe0f Tools"},{"location":"docs/slackbot/overview/#poetry","text":"A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it.","title":"Poetry"},{"location":"docs/slackbot/overview/#invoke","text":"You will find a packaged called Invoke installed within the virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy.","title":"Invoke"},{"location":"docs/slackbot/overview/#dockerfile","text":"A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment. A couple of additional Invoke tasks are listed below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. invoke shell Get access to the BASH shell within our container.","title":"Dockerfile"},{"location":"docs/slackbot/overview/#workflow","text":"The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Run locally or within a container using the Invoke package poetry install poetry shell invoke configure","title":"\ud83d\ude80 Workflow"}]}